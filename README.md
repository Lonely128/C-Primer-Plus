# C Primer Plus
总说明：红色字体为我自己的注释，蓝色为重点说明。
C语言是一种融合了控制特性的现代语言
面向对象编程试图让语言适应问题，而不是让问题来适应语言
C是一种编译性语言
集成开发环境IDE
目标文件只包含所编写的代码转换成的机器语言，可执行文件还包含你所使用的库例程以及启动代码的机器代码

第2章
1.	C语言中的6种语句：标号语句、复合语句、表达式语句、选择语句、迭代语句、跳转语句。
2.	main()：C90标准勉强接受这种形式，但是C99和C11标准不允许这样写。void main()：所有的标准都未认可这种形式。
3.	#include不是C语言语句，#include中的#符号表明，C预处理器在编译器接手前处理这条指令。
4.	C程序一定从main（）函数开始执行。（可能会有特殊情况）
5.	main（）函数返回的值返回给操作系统。
6.	标识符是一个变量、函数或其他实体的名称。
7.	以前的C语言，要求把变量声明在块的顶部，其他语句不能在任何声明的前面。C99和C11遵循C++的惯例，可以把声明放在块中的任何位置。
C99和C11标准允许一个标识符最多有63个字符，对于外部标识符，只允许使用31个字符，C90分别要求31个字符和6个字符
可以用小写字母、大写字母、数字和下划线来命名，名称的第一个字符必须是字符或下划线，不能是数字。
C语言的名称区分大小写。
实际参数是传递给函数的特定值，形式参数是函数中用于储存值的变量。
printf函数名中的f提醒用户，这是一种格式化打印函数。
无论main（）在程序文件处于什么位置，所有的C程序都从main（）开始执行。C的惯例是把main（）函数放在开头，因为它通常为程序提供了最基本的框架。
保留标识符（reserved identifier）包括那些以下划线字符开始的标识符和标准库函数名。

第3章
1.	可打印出来的符号都是字符。
2.	最小的存储单元是位（bit），可以存储0或1。字节（byte）对于几乎所有的机器，均为8位。（C语言把1字节定义为char类型占用的位（bit）数。）字（word）是设计计算机时给定的自然存储单位，对于8位的微型计算机，1个字长只有8位。
3.	以八进制显示数字，使用%o；以十六进制显示数字，使用%x。要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。
4.	char是整数类型。因为char类型实际上存储的是整数而不是字符。（有些C编译器把char实现为有符号类型，而有些C编译器把char实现为无符号类型。）
5.	如果是变量数据，编译器一般通过其书写来辨认其类型，变量则需要在声明语句中制定其类型。
6.	C中基本的数据类型包含两大类：整数类型和浮点数类型。最小的整数类型是char。
7.	要把一个较小的常量作为long类型对待，可以在值的末尾加上l或L后缀。在C中常量后缀可以使用大写和小写，但格式说明符只能使用小写字母。（%d被称为格式说明符（format specifier）。%lx表示以十六进制格式打印long类型整数）（十六进制的浮点型常量用p计数法表示，见第3章第18条，十六进制的整型常量表示见第3章第3条。）
8.	int类型被认为是计算机处理起来最方便有效的整数类型，所以在short类型和int类型长度不同的系统中，使用int类型值进行参数传递的速度更快，但是可以使用h修饰符显示一个较长的整数被截为short类型值时的样子。
9.	一般情况下，long long类型为64位，long类型为32位，short类型为16位，int类型为16位。
10.	C把一个字节（byte）定义为char类型占用的位（bit）数，所以C文档中提到的一个字节是16位或者32位，而不是8位。（对应第3章第2条）
11.	C将字符常量（用单引号括起来的单个字符被称为字符常量）视为int类型而非char类型。【在一个int类型位数比char类型位数多的ASCⅡ系统中，把一个包含多个字母的字符常量（这个字符常量是自定义的）赋给一个char变量，只有最后一个字母会起作用。】
12.	使用转义序列是因为有些字符是打印不出来的。比如：\、’、”、？。
13.	给一个字符变量进行赋值时，转义序列必须用单引号括起来。无论普通字符还是转义序列，如果作为双引号中字符集合的一部分，则无需单引号。双引号中的字符集合称为字符串。
14.	C99标注添加了_Bool类型，所以_Bool类型实际上也是一种整数类型。
15.	C标准规定，float类型必须至少能表示6位有效数字（这里的有效数字跟数学的定义不同，就是指小数点后6位），取值范围至少为10-37到10+37。Double类型必须至少能表示10位有效数字，实际分配方法使得数值至少具有13位有效数字，超出了C的最小标准规定。
16.	浮点型常量可以省略正号（指的是用指数法表示时指数部分的正号）。可以没有小数点或指数部分，但是不能同时没有二者。可以省略纯小数部分或整数部分，但是二者不能同时省略。不要在浮点型常量中间加空格。
17.	默认情况下，编译器将浮点常量当做double类型，可以通过在浮点数后面加上f或F后缀使编译器把浮点常量当做float类型（注意与下一条比对），l或L后缀使一个数字成为long double类型。
18.	float和double类型的输出都使用%f、%e或%a说明符。%e打印指数计数法的数字，C99支持十六进制格式浮点数，在十六进制数前加上十六进制前缀（0X或0x），用p和P分别代替e和E，用2的幂代替10的幂（即p计数法）。（这里指的是输出结果）转换说明时则用a或A代替e或者E。
19.	printf（）函数使用%f转换说明打印十进制计数法的float和double类型浮点数。打印long double类型要使用%Lf、%Le或%La转换说明。（与第3章第5条对比）
20.	C语言没有字符串类型。
21.	sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型（即size_t类型），一些不支持C99和C11的编译器可以用%u或%lu代替%zd。
22.	基本数据类型使用11个关键字：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。
23.	C语言用逗号分隔函数中的参数。（可以帮助理解for语句中为什么用；而不是用，）
24.	当为某个数值类型的变量进行初始化时，如果使用了其他类型的值，C会自动对该数值进行类型转换以便和变量类型进行匹配。注意，使用%d显示float值不会把该float值转换为近似的int值，而是显示垃圾值。类似的，使用%f显示int值也不会把该int值转换成浮点值。（注意两者的区别，什么时候不同的类型会相互转换，什么时候不会相互转换，把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。）
25.	C标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区满、遇到换行字符或需要输入的时候。

第4章
1.	C语言没有专门用于存储字符串的变量类型，字符串都被储存在char类型的数组中。
2.	scanf（）在遇到第一个空白（空格、制表符或换行符）时就不再读取输入。
3.	用大写表示符号常量是C语言一贯的传统。
4.	在C语言中，用const类型限定符声明的是变量，不是常量。
5.	printf()使用的是值，无论该值是变量、常量还是表达式。
6.	想用printf打印单独的%符号，使用两个%符号即可。（注意与转义序列区分开，转义序列表示ASCⅡ打印不出来的字符，其中不包含%，而%%是转换说明）
7.	printf（）中的标记：空格可以在正值之前产生前导空格，负值之前不产生前导空格，使得有效位相同的正值和负值一相同字段宽度打印输出。
8.	printf（）函数返回打印字符的个数。注意计算针对所有字符数，包括空格和不可见的换行符（\n）。（转义序列算作字符，换行符应该算1）
9.	当printf（）语句很长，以至于不能在一行被放下，可以在多行放置一个语句，但是不能在引号括起来的字符串中间断行。给字符串断行有3中方法，方法1：使用多个printf()语句。方法2：用反斜杠（\）和Enter（或Return）键组合来断行。但是，下一行代码必须和程序清单中的代码一样从最左边开始。方法3：在两个用双引号括起来的字符串之间用空白隔开。
10.	scanf（）函数使用指向变量的指针。
11.	scanf（）函数使用空白（换行符、制表符和空格）把输入分为多个字段。在一次把转换说明和字段匹配时跳过空白。（自动跳过待输入值前面所有的空白）唯一的例外是%c转换说明，scanf（）会读取每个字符，包括空白。
12.	对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把他们用于float类型，对于double类型时要使用l修饰符。
13.	当scanf() 把字符串放进制定数组中时，它会在字符序列的末尾加上’\0’，让数组中的内容成为一个C字符串。
14.	scanf()函数允许把普通字符放在格式字符串中。出空格字符外的普通字符必须与输入字符串严格匹配。格式字符串中的空格意味着跳过下一个输入项之前的所有空格。“所有空白”的概念包括没有空格的特殊情况。
15.	除了%c，其他转换说明都会自动跳过输入值前面所有的空白。对于%c，在格式字符串中添加一个空格字符会有所不同。如果把%c放在格式字符串中的空格前面，scanf()便会跳过空格，从第1个非空白字符开始读取。
16.	scanf()函数返回成功读取的项数。（读取数字和肚脐其他项时，如果没有读取任何项，返回值是不同的。）
17.	EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1.
18.	printf（）中，可以在字段宽度部分使用*代替数字来让程序指定字段宽度；scanf（）中，当*放在%和说明符之间时，它使函数跳过相应的输入项目。

第5章
1.	C没有指数运算符。C的标准数学库提供了一个pow()函数用于指数运算。
2.	负数的整数除法在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。
3.	求模运算符只能用于整数，不能用于浮点数。
4.	C99标准为整数求模规定：无论何种情况，如果a和b都是整数值，可以通过从a-（a/b）*b来计算a%b。（主要为解决负数求模的问题，如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数。）
5.	增量运算符和减量运算符只能影响一个变量。优先级告诉我们什么时候使用变量的值计算表达式，而增量运算符的性质决定了什么时候改变变量的值。（如果n++是表达式的一部分，可将其视为“先使用n，再递增”；而++n则表示“先递增n，再使用”。）
6.	如果一个变量出现在同一个函数的多个参数中时，不要将增量或者减量运算符用于它上面；当一个变量多次出现在一个表达式里时，不要将增量或减量运算符用到它的上面。（在C语言中，编译器可以自行选择先对函数中的哪个参数求值。）
7.	一个声明语句不是一个表达式语句，如果从声明语句中去掉分号，所得到的不是一个表达式，也不具有一个值。（根据C标准，声明不是语句，这与C++不同）
8.	在C语言中，赋值和函数调用都是表达式。没有所谓的“赋值语句”和“函数调用语句”，这些语句实际上都是表达式语句。（表达式语句就是末尾加上一个分号的表达式，表达式是有运算符和运算对象组成，表达式的最重要的特征就是有一个值。）
9.	一个序列点是程序执行中的一点，在该点处，所有的副作用都在进入下一步前发生。（对照第5章第6条，只能保证序列点处肯定会发生，但不保证具体何时发生。）副作用是对数据对象或文件的修改。（从C语言的角度看，主要目的是对表达式求值。）

第6章
1.	使用while时，只有在测试条件后面的单独语句（简单语句或复合语句）才是循环部分。（在没有花括号时注意，跟Python不同的是，缩进只是为了方便阅读，不是计算机的要求。）
2.	在C语言中，单独的分号表示空语句。所以while(expression);中，测试条件后面的单独分号是空语句，它什么也不做。
3.	使用关系等于运算符检查左边与右边的值是否相等时，如果进行比较的双方中有一个是常量，则可以把它放在表达式的左边。
4.	关系表达式在为真时值为1，为假时值为0；非零值被认为是“真”，零值被认为是“假”。_Bool类型的变量只能存储1（真）和0（假）。如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1。
5.	for循环关键字for后面的圆括号中有3个控制表达式，它们都是完整表达式，所以每个表达式的副作用都发证在对下一个表达式求值之前。（所以for循环圆括号里面用分号隔开。）
6.	逗号运算符保证了被它分隔的表达式从左往右求值。（逗号是一个序列点。左边产生的所有副作用都在程序执行逗号右侧项之前生效。）整个逗号表达式的值是右边成员的值。
7.	for循环可以省略一个或多个表达式，但是不能省略分号。（指的是圆括号里面。）
8.	注意区分+=和=+，例如n=+1和n+=1,前一个是n=（+1），后一个是n=n+1。
9.	数组的第一个元素的索引编号为0，第二个为1。

第7章
除了两个运算符共享一个操作数的情况以外，C通常不保证复杂表达式的哪个部分首先被求值。一个例外是对逻辑运算符的处理。C保证逻辑表达式是从左到右求值的。&&和||运算符是序列的分界点。（分为左值和右值）
ctype.h中的字符映射函数不会修改原始的参数，只会返回已修改的值。
逻辑运算符：！运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。
如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。（注意if语句不是循环语句，而是条件语句）
对于while和do while循环，执行continue语句后的下一个行为是对循环的测试表达式求值；对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。
在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第一条语句，连更新部分也跳过。
break语句可用于循环和switch语句中，但是continue只能用于循环中。
Switch在圆括号中的测试表达式的值必须是一个整数值（包括char类型）。Case标签必须是整数类型（包括char类型）的常量或整型常量表达式，不能用变量作为case标签。
原则上，根本不用在C程序中使用goto语句，但是，可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出。
要测试两个条件，应该使用逻辑运算符把两个完整的测试表达式组合起来。

第8章
通常，EOF定义在stdio.h文件中：#define EOF （-1）。（第4章第17条）

第9章
递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。递归函数位于递归调用之后的语句，均按被调函数相反的顺序执行。
*和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。

第10章
如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值；如果部分初始化数组，剩余的元素就会被初始化为0。如果初始化列表的项数多于数组元素个数，编译器会将其视为错误。
C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素。
数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小。
sizeof表达式被视为整型常量，但是const不是。
数组名是数组元素的地址。是常量。
转换说明符通常以十六进制显示指针的值。
指针加1指的是增加一个存储单元。这是为什么必须声明指针所指向对象类型的原因之一。
只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar。
C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。
一元运算符*和++的优先级相同，但结合律是从左往右。
如果编译器不支持%p转换说明，可以用%lu或%u代替%p；如果编译器不支持用%td转换说明打印地址的差值，可以用%d或%ld来代替。
可以把地址赋给指针，地址应该和指针类型兼容。
求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。
千万不要解引用未初始化的指针。
创建一个指针时，系统只分配了存储指针本身的内存，并未分配存储数据的内存。在使用指针之前，必须先用已分配的地址初始化它。
指向const的指针不能用于改变值。无论是使用指针表示法还是数组表示法，都不允许使用指针改变它所指向数据的值；const指针可以修改它所指向的值，但是它只能指向初始化时设置的地址。
把const数据或非const数据的地址初始化为指向const的指针或为其赋值时合法的。然而，只能把非const数据的地址赋给普通地址。（否则，通过指针就能改变const数组中的数据）
可以用数组表示法或者指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名。

第11章
让编译器计算数组的大小只能用在初始化数组时。
在把指针初始化为字符串字面量时使用const限定符，因为未使用const限定符的指针初始化，使用该指针修改这个字符串，对于当前的C标准而言，这样的行为是未定义的。把非const数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。
如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。
Strcmp（）函数比较的是字符串，不是整个数组，可以用strcmp（）比较储存在不同大小数组中的字符串。
在字母表中，如果第1个字符串在第2个字符串前面，strcmp（）返回一个负数；如果两个字符串相同，strcmp（）返回0；如果第1个字符串在第2个字符串后面，strcmp（）返回正数。
Strcpy（）接受两个字符串指针作为参数，指向源字符串副本的第1个指针应指向一个数据对象，且该对象有足够的空间储存源字符串的副本。

第12章
Const放在*左侧任意位置，限定了指针指向的数据不能改变；const放在*右侧，限定了指针本身不能改变。
